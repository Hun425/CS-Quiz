# 모듈형 마이크로서비스 아키텍처(MMA) 전환 가이드

## 1. 아키텍처 개요

현재 프로젝트는 모놀리식 아키텍처에서 모듈형 마이크로서비스 아키텍처(MMA)로 전환 중입니다. 이 전환의 핵심 목표는 다음과 같습니다:

1. **기능 유지**: 모든 기능이 원래대로, 또는 더 나은 상태로 작동해야 합니다.
2. **의존성 최소화**: 각 모듈별로 의존성을 최소화하여, 독립적으로 개발하고 배포할 수 있어야 합니다.
3. **이벤트 기반 통신**: 모듈 간 직접 의존성을 줄이고, 대신 Kafka를 통한 이벤트 기반 통신을 채택합니다.

## 2. 모듈 구조

전체 시스템은 다음 모듈들로 구성됩니다:

### 2.1 Common 모듈
- 모든 모듈에서 공유되는 코드와 인터페이스를 제공합니다.
- 주요 책임: 이벤트 인터페이스 정의, 공통 유틸리티, 도메인 이벤트, 모델 정의 등

### 2.2 API Gateway 모듈
- 시스템의 단일 진입점으로 작동합니다.
- 외부 요청을 적절한 내부 모듈로 라우팅합니다.

### 2.3 User 모듈
- 사용자 관리와 인증/인가 담당
- 주요 책임: 회원가입, 로그인, 사용자 프로필, 권한 관리

### 2.4 Quiz 모듈
- 퀴즈 관리 담당
- 주요 책임: 퀴즈 생성, 조회, 수정, 답변 검증

### 2.5 Battle 모듈
- 실시간 퀴즈 대결 관리
- 주요 책임: 대결 방 생성, 참가자 관리, 점수 관리, 실시간 업데이트

## 3. 모듈 내부 구조 (헥사고날 아키텍처)

각 모듈은 다음과 같은 헥사고날 아키텍처 계층을 따릅니다:

### 3.1 도메인 계층 (Domain)
- 핵심 비즈니스 로직과 도메인 모델을 담당
- 다른 계층에 대한 의존성이 없어야 함
- 서브패키지: entity, model, event

### 3.2 애플리케이션 계층 (Application)
- 유스케이스를 구현하고, 도메인 계층의 로직을 조율
- 서브패키지: service, port (in/out)

### 3.3 어댑터 계층 (Adapter)
- 외부 시스템과의 통신 담당
- 인바운드 어댑터 (들어오는 요청 처리): 서브패키지: adapter/in
- 아웃바운드 어댑터 (외부 시스템 호출): 서브패키지: adapter/out

## 4. 이벤트 기반 통신

모듈 간 통신은 주로 Kafka를 통한 비동기 이벤트 기반 방식으로 이루어집니다:

### 4.1 이벤트 정의
- 모든 이벤트는 `common` 모듈에 정의됨
- 각 이벤트는 고유 ID, 타임스탬프, 관련 데이터를 포함

### 4.2 이벤트 발행
- `EventPublisher` 인터페이스와 `KafkaEventPublisher` 구현체를 통해 발행
- 각 모듈은 특정 토픽으로 이벤트 발행

### 4.3 이벤트 구독
- `@KafkaListener` 어노테이션을 사용하여 이벤트 구독
- 각 모듈마다 이벤트 리스너 클래스를 구현

## 5. 통합 테스트 전략

모듈 간 통신이 잘 작동하는지 확인하기 위한 전략:

### 5.1 단위 테스트
- 각 모듈의 비즈니스 로직을 독립적으로 테스트

### 5.2 통합 테스트
- 이벤트 발행-구독 메커니즘을 테스트
- KafkaTemplate과 Listener가 올바르게 동작하는지 확인
- EmbeddedKafka를 사용하여 Kafka 의존성 없이 테스트 가능

### 5.3 엔드 투 엔드 테스트
- 전체 시스템의 흐름을 테스트
- API Gateway를 통한 요청부터 모든 모듈이 제대로 동작하는지 확인

## 6. 모듈 간 의존성 관리

### 6.1 직접 의존성 최소화
- 모듈 간 직접 호출은 최소화하고, 대신 이벤트 기반 통신 사용
- 직접 의존성이 필요한 경우, API Gateway를 통한 REST 호출 사용

### 6.2 공통 코드 관리
- 공통 코드는 common 모듈에 배치
- common 모듈은 다른 모듈의 코드에 의존하지 않아야 함

## 7. 배포 전략

### 7.1 독립적 배포
- 각 모듈은 독립적으로 배포 가능해야 함
- Docker 컨테이너를 사용하여 각 모듈 패키징

### 7.2 설정 관리
- Spring Cloud Config Server를 사용하여 중앙 집중식 설정 관리
- 환경별 설정 분리 (개발, 테스트, 프로덕션)

### 7.3 서비스 디스커버리
- Spring Cloud Eureka를 사용하여 서비스 디스커버리 구현
- API Gateway에서 서비스 라우팅 시 활용

## 8. 모니터링 및 로깅

### 8.1 분산 추적
- Spring Cloud Sleuth와 Zipkin을 사용하여 분산 추적 구현
- 요청의 전체 흐름을 추적하고 병목 지점 식별

### 8.2 중앙 집중식 로깅
- ELK 스택(Elasticsearch, Logstash, Kibana)을 사용하여 로그 관리
- 모든 모듈의 로그를 중앙에서 수집하고 분석

### 8.3 메트릭 모니터링
- Prometheus와 Grafana를 사용하여 시스템 메트릭 모니터링
- 각 모듈의 성능 및 상태 지표 수집

## 9. 단계별 전환 계획

### 9.1 단계 1: 공통 모듈 구현
- 이벤트 인터페이스, 모델, 유틸리티 등 구현
- 카프카 설정 및 이벤트 발행-구독 메커니즘 구현

### 9.2 단계 2: 모듈별 분리
- 기존 코드를 모듈별로 분리하여 재구성
- 각 모듈 내부에 헥사고날 아키텍처 적용

### 9.3 단계 3: 이벤트 기반 통신 구현
- 모듈 간 직접 호출을 이벤트 기반 통신으로 전환
- 이벤트 발행자와 구독자 구현

### 9.4 단계 4: API Gateway 구현
- 단일 진입점 구현
- 라우팅, 인증, 권한 부여 등 구현

### 9.5 단계 5: 인프라 구성
- Docker, Kubernetes 등을 사용한 배포 인프라 구성
- CI/CD 파이프라인 구성

### 9.6 단계 6: 통합 테스트 및 안정화
- 전체 시스템 통합 테스트
- 성능 테스트 및 최적화

## 10. 유의 사항

### 10.1 이벤트 스키마 관리
- 이벤트 스키마 변경 시 호환성 유지
- 버전 관리 전략 수립

### 10.2 트랜잭션 관리
- 분산 환경에서 트랜잭션 일관성 유지
- Saga 패턴 적용 고려

### 10.3 오류 처리 및 복구
- 장애에 대비한 오류 처리 및 복구 메커니즘 구현
- 이벤트 재시도, 데드레터 큐(DLQ) 등 활용

### 10.4 보안
- API Gateway에서 인증 및 권한 부여 중앙화
- 모듈 간 통신의 보안 고려

## 11. 결론

모듈형 마이크로서비스 아키텍처(MMA)로의 전환은 시스템의 확장성, 유지보수성, 개발 생산성을 향상시키는 목표를 가지고 있습니다. 단계적인 접근 방식과 명확한 아키텍처 원칙을 통해 성공적인 전환이 가능할 것입니다.
